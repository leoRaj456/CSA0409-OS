#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

sem_t mutex;      // Protects read_count
sem_t rw_mutex;   // Allows either multiple readers OR one writer
int read_count = 0;

void *reader(void *arg) {
    int id = *(int *)arg;

    while (1) {
        // Entry section
        sem_wait(&mutex);
        read_count++;
        if (read_count == 1)
            sem_wait(&rw_mutex); // First reader locks writers
        sem_post(&mutex);

        // Critical section
        printf("Reader %d is reading...\n", id);
        usleep(100000);  // simulate reading

        // Exit section
        sem_wait(&mutex);
        read_count--;
        if (read_count == 0)
            sem_post(&rw_mutex); // Last reader unlocks writers
        sem_post(&mutex);

        usleep(200000); // simulate time outside CS
    }
}

void *writer(void *arg) {
    int id = *(int *)arg;

    while (1) {
        // Entry section
        sem_wait(&rw_mutex); // Only one writer at a time

        // Critical section
        printf("Writer %d is writing...\n", id);
        usleep(150000); // simulate writing

        // Exit section
        sem_post(&rw_mutex);

        usleep(300000); // simulate time outside CS
    }
}

int main() {
    pthread_t rtid[5], wtid[2];
    int r_id[5], w_id[2];

    // Initialize semaphores
    sem_init(&mutex, 0, 1);
    sem_init(&rw_mutex, 0, 1);

    // Create reader threads
    for (int i = 0; i < 5; i++) {
        r_id[i] = i + 1;
        pthread_create(&rtid[i], NULL, reader, &r_id[i]);
    }

    // Create writer threads
    for (int i = 0; i < 2; i++) {
        w_id[i] = i + 1;
        pthread_create(&wtid[i], NULL, writer, &w_id[i]);
    }

    // Join threads (unreachable in infinite loop)
    for (int i = 0; i < 5; i++)
        pthread_join(rtid[i], NULL);
    for (int i = 0; i < 2; i++)
        pthread_join(wtid[i], NULL);

    return 0;
}
